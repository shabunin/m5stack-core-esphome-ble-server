substitutions:
  name: "m5stack-core"

globals:
  - id: global_ble_rx_buf
    type: std::string
    restore_value: no
    initial_value: ""
  - id: global_alarms
    type: std::vector<uint32_t>
    restore_value: no  # persistent across reboots
  - id: my_menu_root
    type: display_menu_base::MenuItemMenu*
    initial_value: 'nullptr'

esphome:
  name: "${name}"
  name_add_mac_suffix: true
  project:
    name: bobalus.m5stack-core
    version: "1.0"
  includes:
    - alarm_defs.h

esp32:
  board: m5stack-core-esp32
  framework:
    type: esp-idf

external_components:
  - source:
      type: git
      url: https://github.com/ssieb/custom_components
    components: [ip5306]

logger:

uart:
  rx_pin: 16
  baud_rate: 9600

i2c:
  sda: 21
  scl: 22
  scan: true
  frequency: 400kHz

spi:
  clk_pin: 18
  mosi_pin: 23
  miso_pin: 19
  interface: any

# battery
ip5306:
  battery_level:
    name: ${name}-battery-level
    id: battery_percent
  charger_connected:
    name: ${name} Charger Connected
    id: connected
  charge_full:
    name: ${name} Charge Full
    id: full
        
binary_sensor:
  - platform: gpio
    name: "M5_BtnA"
    pin:
      number: 39
      inverted: true
    on_click:
      min_length: 0s
      max_length: 10s
      then:
        - display_menu.up: my_menu
  - platform: gpio
    id: M5_BtnB
    pin:
      number: 38
      inverted: true
    on_click:
      min_length: 0s
      max_length: 10s
      then:
        - display_menu.enter: my_menu
  - platform: gpio
    id: M5_BtnC
    pin:
      number: 37
      inverted: true
    on_click:
      min_length: 0s
      max_length: 10s
      then:
        - display_menu.down: my_menu
        
font:
  - file: "gfonts://Roboto@medium"
    id: my_font
    size: 22
    glyphs: '!"%()+,-_.:°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz/³µ'

# GPIO pin of the display backlight
output:
  - platform: ledc
    pin: 32
    id: gpio_32_backlight_pwm
    
light:
  - platform: monochromatic
    output: gpio_32_backlight_pwm
    name: "Display Backlight"
    id: back_light
    restore_mode: ALWAYS_ON


graphical_display_menu:
  id: my_menu
  font: my_font
  active: true
  on_redraw:
    then:
      component.update: m5stack_display
  items:
    - type: Label
      text: ---


display:
  - platform: ili9xxx
    id: m5stack_display
    model: M5Stack
    invert_colors: false
    color_palette: 8BIT
    data_rate: 20MHz
    spi_mode: 3
    cs_pin: 14
    dc_pin: 27
    reset_pin: 33
    rotation: 0
    update_interval: 300s
    lambda: |-
        
        const auto width = it.get_width();
        const auto height = it.get_height();
        it.menu(0, 16, id(my_menu), width, height-16);

json:

esp32_ble_server:
  services:
    - uuid: "6E400001-B5A3-F393-E0A9-E50E24DCCA9E"  # Nordic UART
      characteristics:
        - uuid: "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"  # TX (notify)
          read: true
          notify: true
          id: tx_char
        - uuid: "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"  # RX (write)
          write: true
          on_write:
            then:
              - lambda: |-
                  std::string frag(x.begin(), x.end());
                  ESP_LOGI("BLE", "RX Fragment: %s", frag.c_str());

                  // Append fragment to buffer
                  id(global_ble_rx_buf) += frag;

                  // Process complete messages (starting with \x10GB( and ending with )\n)
                  size_t start = id(global_ble_rx_buf).find("\x10GB(");
                  size_t end = id(global_ble_rx_buf).find(")\n", start);

                  while (start != std::string::npos && end != std::string::npos) {
                    std::string json_part = id(global_ble_rx_buf).substr(start + 4, end - start - 4);
                    ESP_LOGI("BLE", "RX Full Message: %s", json_part.c_str());

                    StaticJsonDocument<4096> doc;
                    DeserializationError err = deserializeJson(doc, json_part.c_str());
                    if (err) {
                      ESP_LOGW("BLE", "Invalid JSON");
                    } else {
                      std::string type = doc["t"] | "";
                      ESP_LOGI("BLE", "Parsed type: %s", type.c_str());

                      if (type == "notify") {
                        ESP_LOGI("BLE", "Notification from %s: %s", doc["src"] | "", doc["title"] | "");
                      } else if (type == "notify-") {
                        ESP_LOGI("BLE", "Delete notification ID %d", doc["id"] | 0);
                      } else if (type == "find") {
                        bool on = doc["n"] | false;
                        ESP_LOGI("BLE", "Find device: %s", on ? "ON" : "OFF");
                      } else if (type == "vibrate") {
                        int dur = doc["n"] | 0;
                        ESP_LOGI("BLE", "Vibrate for %d ms", dur);
                      } else if (type == "weather") {
                        ESP_LOGI("BLE", "Weather: temp=%.1f°C hum=%.1f%%", doc["temp"] | 0.0f, doc["hum"] | 0.0f);
                      } else if (type == "musicstate") {
                        ESP_LOGI("BLE", "Music state: %s", doc["state"] | "");
                      } else if (type == "musicinfo") {
                        ESP_LOGI("BLE", "Now playing: %s - %s", doc["artist"] | "", doc["track"] | "");
                      } else if (type == "call") {
                        ESP_LOGI("BLE", "Call %s from %s", doc["cmd"] | "", doc["name"] | "");
                      } else if (type == "gps") {
                        ESP_LOGI("BLE", "GPS: lat=%.6f lon=%.6f alt=%.1f", doc["lat"] | 0.0, doc["lon"] | 0.0, doc["alt"] | 0.0);
                      } else if (type == "is_gps_active") {
                        ESP_LOGI("BLE", "GPS status requested");
                        const char* gps_resp = R"({"t":"gps_power","status":false})";
                        std::vector<uint8_t> out(gps_resp, gps_resp + strlen(gps_resp));
                        id(tx_char).set_value(out);
                        id(tx_char).notify();
                      } else if (type == "alarm") {
                        id(global_alarms).clear();  // overwrite with new list
                        JsonArray alarms = doc["d"].as<JsonArray>();

                        for (JsonObject alarm : alarms) {
                          uint8_t h = alarm["h"] | 0;
                          uint8_t m = alarm["m"] | 0;
                          uint8_t rep = alarm["rep"] | 0;
                          bool on = alarm["on"] | true;

                          uint32_t packed =
                              ((uint32_t)m) |
                              ((uint32_t)h << 8) |
                              ((uint32_t)rep << 16) |
                              ((uint32_t)on << 23);

                          id(global_alarms).push_back(packed);
                          ESP_LOGI("ALARM", "Stored: %02d:%02d rep=%02x on=%d", h, m, rep, on);
                        }
                        
                        // now recreate alarm menu
                        if (id(my_menu_root) != nullptr) {
                          delete id(my_menu_root);
                          id(my_menu_root) = nullptr;
                        }

                        auto* root = new display_menu_base::MenuItemMenu();
                        id(my_menu_root) = root;
                        id(my_menu)->set_root_item(root);

                        const char* days[] = {"Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"};

                        for (const auto &a : id(global_alarms)) {
                          if (!ALARM_ON(a)) continue;

                          uint8_t h = ALARM_HOUR(a);
                          uint8_t m = ALARM_MIN(a);
                          uint8_t rep = ALARM_DAYS(a);

                          char buf[64];
                          snprintf(buf, sizeof(buf), "%02d:%02d ", h, m);

                          for (int i = 0; i < 7; i++) {
                            if (rep & (1 << i)) {
                              strcat(buf, days[i]);
                              strcat(buf, " ");
                            }
                          }
                    
                          auto* item = new display_menu_base::MenuItem(display_menu_base::MENU_ITEM_LABEL);
                          item->set_text(buf);
                          root->add_item(item);
                        }

                        if (root->items_size() == 0) {
                          auto* item = new display_menu_base::MenuItem(display_menu_base::MENU_ITEM_LABEL);
                          item->set_text("(no alarms)");
                          root->add_item(item);
                        }
                        
                        id(my_menu).show_main();
                        id(m5stack_display).update();

                      } else {
                        ESP_LOGW("BLE", "Unhandled type: %s", type.c_str());
                      }
                    }

                    // Remove parsed message from buffer
                    id(global_ble_rx_buf).erase(0, end + 2);

                    // Search for another message
                    start = id(global_ble_rx_buf).find("\x10GB(");
                    end = id(global_ble_rx_buf).find(")\n", start);
                  }

                  // Optional: prevent buffer overflow
                  if (id(global_ble_rx_buf).length() > 2048) {
                    ESP_LOGW("BLE", "BLE buffer overflow, clearing");
                    id(global_ble_rx_buf).clear();
                  }